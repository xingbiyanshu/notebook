# 现代C++

## 旧事物的替代

- const变量和inline函数替代宏定义
- 匿名命名空间替代static
- std::optinal替代返回null
- std::variant替代union
- std::any替代Object（variant是范围有限的any）
- static_cast替代括号形式的强制类型转换
- std::span替代“数组名（指针）+数组大小”的传参方式
- noexcept替代throw
- 抛出异常替代返回错误码

## 什么是左值和右值？

按字面义解释，左值即为"="左侧的值，右值即为右侧的值。如int a=1; a为左值，1为右值。
然而这只是约定俗成的叫法，左右值的本质并不是指它相对"="的位置，依据这种方式判断左右值很容易出错。
左值的本质是它在“内存”中有个存储位置，可以在该位置存储值，特点生命周期相对右值较长；
而右值的本质是它只是一个字面值（纯右值，只在寄存器中存在过）或临时对象（將亡值，在内存中短暂存在过，转瞬即逝）。

````c++
/*
a是个变量是左值，在内存中有存储位置，这个位置存储的值是1。
但1只是一个字面值，它只在“寄存器”中存在过，在内存中没有存储位置，不能对它取地址"&1"。
*/
int a=1;
...

Stu test(){...} // Stu为自定义类
...
test(); // test()的返回值在这行执行过后即被析构，再无法找到，这就是所谓的“临时性”、“將亡值”，所以test()的返回值是右值。
Stu ret=test(); // 你可以将它拷贝或赋值给一个左值从而“记录”该返回值（注意是“拷贝”并非“引用”，这行过后返回值本身也没有了，只是它的值已经拷贝给ret了）
//Stu& rret=test(); // 错误：不能将右值绑定到左值引用！test()是右值，而rret是左值引用，这是不允许的。
Stu&& rret=test(); // 你可以通过将它“绑定”到一个右值引用，从而使得返回值的生命周期得以延长至跟该引用生命周期一样。
                   //（注意和“Stu ret=test()”的区别，这里返回值的生命周期绑定到了rret，它没有消失，所以这里“避免了将test()的值拷贝给rret”，这对于效率提升是很有意义的）。
                    // 可能有的小伙伴会想为什么编译器不能让“Stu& rret=test();”达到同样的目的呢，编译器应该变得更加智能，而减少程序员使用上的负担。
                    // 或许技术上来论证是可行的，但C++不是一门全新的语言，它有许多历史包袱，这样做可能导致原来的实现无法运行，而一种兼容的方案可能又太难找寻甚至是不可能。
Stu &r=rret; // 右值引用本身是个左值，所以你可以将它绑定到左值引用。
````

## 如何判别左值和右值？

等号左侧的为左值，右侧的为右值？
从形式上说，多数情况下成立，但这种判断方式太机械，反映不了左右值的本质，很容易误判：

````c++
string s = "hello"; // 字符串字面值在等号右侧，但它是左值。反过来说"hello"=s是不可以的，即左值不一定可以放在等号左侧。
int a=1;
int b=a; // a在右侧，但是左值，除非结合前一条语句综合判断。

int& test(int& i){
    return i;  // 特别注意不能返回局部变量的引用。
}
int c = test(a); // test(a)在右侧
test(a) = 2;  // 但它是左值
````

左值有名字，右值没有名字？
类似"test(a)"这种返回值没有名字但它是左值。
而且“有没有名字”含义上就很模糊，不好作为判断依据：

````c++
enum Color{
    RED,
    BLUE,
}
Color c=RED; // RED你可以说它是有名字的，但它是右值

````

左值可以取地址(&)，右值不可以？
这个描述基本正确，而且反映了左右值的本质。但是描述再完善一些可以避免某些场景下的误判：
左值可以使用“内置的”取地址操作，右值不可以。
因为C++允许操作符重载，如果用户自定义了"&"操作符则右值也可能使用它，所以限定为“内置的”。

一些常见的左值：
各种变量定义，如：int a; Student s; int &&b=1;(**特别注意：b虽然是右值引用类型，但它本身是变量，是左值。它也是引用，跟左值引用的唯一区别是它只能绑定右值，在左右值这个属性上它跟左值引用是一样的**)
字符串字面值，如："hello"；
内置的前置++与--（后置的是右值，因为后置的是先返回临时变量而后才执行++，前置的是执行完后返回，如++a返回的仍是a这个左值，a++返回的则是中间的临时变量并非a）；
转型为左值引用的表达式，如：static_cast<double&>(fValue);
内置解引用的表达式，如：*p;

一些常见的右值：
非字符串的字面值，如：1,true,nullptr；
内置的后置++和--；
内置的算术、逻辑、比较表达式，如：a+b,a&b,a||b, a< b；
内置取地址表达式，如：&a;
lamda表达式,如：[](int a){ return 2*a; }；
转型为非引用的表达式，如：static_cast<double>(fValue); (float)42;
转型为右值引用的表达式，如：static_cast<double&&>(fValue)，std::move(x);

## 左值右值之间如何转换？

右值不能转左值，或者说右值可以通过拷贝或赋值给一个左值实现“转换”。

左值转右值：

````c++
// 使用move
int a=1;
int&& b=std::move(a);
// 强制类型转换
int&& c=static_cast<int &&>(a);
int&& d=reinterpret_cast<int &&>(a);
int&& e=(int &&)(a);
// 使用forward（注意forward和move的区别）
int&& b=std::forward<int &&>(a);

````

## 什么是引用？引用和指针的区别？

引用是变量的别名。
引用和指针作为参数时，都可以避免拷贝，提高传递效率，然而他们存在很大不同：
指针是一个变量，该变量的内容是另一个变量的地址；引用是另一个变量的别名，共享该变量的地址。
指针可以重新赋值改变指向；引用须定义同时初始化且后续不可改变指向，始终指向原始绑定对象。（int a=1; int b=2; int& c=a; c=b; 这里“c=b”不是重新绑定，而是赋值，可以在其后加上“b=3”，此时c仍然会是2）
指针可以为null；引用不可以。
使用指针需要进行解引用（因为中间多一层寻址）；引用因为只是别名（共享原始变量地址）可以直接使用，就像使用原始变量一样。
指针可以有多级，即指针的指针；不存在引用的引用（int& & b=a;这样的定义会报错）。
sizeof(指针)得到的是指针本身的大小；sizeof(引用)得到的是引用绑定的对象的大小。如64位机器上sizeof(p)=8,sizeof(rInt)=4。同样的还有自增自减操作。
优先考虑使用引用。

## 为什么有了指针还要发明引用？

初衷是为了方便操作符重载。（C++语言的设计和演化(Bjarne Stroustrup著)）
https://blog.csdn.net/a3192048/article/details/84621775

实践中引用对比指针还有如下好处：
使用起来直接便利，而指针使用起来还要“取地址”“解引用”等操作太麻烦；
避免了野指针；
避免了null指针；
避免误操作改变指针的指向；

但是引用不能替代指针：
指针可以用于管理堆内存，引用一般用于参数传递避免拷贝的同时使用上较指针安全便利；
指针可用于函数参数接受null的场景，以及函数返回值null表示异常的场景，而引用不允许null值；

总结起来就是：
引用主要用来传参和返回值，这些场景下指针也能用，但引用更安全（没有野指针空指针）便捷（无需解引用），所以能用引用的场景尽量用引用；
指针除了可用于传参和返回值，还可以用于堆内存管理；

## 什么是左值引用、右值引用、通用引用、引用折叠、完美转发？

左值引用：引用左值的引用。
右值引用：引用右值的引用。

通用引用：既可以被解析为左值引用也可以被解析为右值引用，并且既可以绑定到const/volatile也可以绑定到非const/volatile。
         简单说它几乎可以绑定到任意对象。这样一种特殊的引用称为通用引用。它在形式上同右值引用“T&&”（T前不能添加任何修饰符如const）。
         两种场景下会出现通用引用，最常见的是函数模板形参：
         template<typename T> void f(T&& param); //param是一个通用引用
         int a=1;
         f(a); // a是左值，param被推导为左值引用int&
         f(1); // 1是右值，param被推导为右值引用int&&
         另一种情况是auto声明：
         auto&& var2 = var1;   //var2是一个通用引用
         这两种情况的共同之处就是都存在“类型推导”。
         
         特别注意这样的不是通用引用：
         template<class T, class Allocator = allocator<T>>   //来自C++标准
        class vector
        {
        public:
            void push_back(T&& x); // T是类模板中的模板参数，类实例化时T已经确定了，所以x此处只是一个普通的右值引用。
            …
        }

引用折叠：引用折叠是配合通用引用使用的，用于指导“编译器”在通用引用的类型推导中生成“引用的引用”这种非法代码后应如何应对（如何折叠为单个引用）。
         对于“template<typename T> void func(T&& para){...}”这样的定义来说。
         若传入的参数为左值，则para会被推导为左值引用，若传入右值，para被推导为非引用（并非右值引用）。所以假设有如下代码：
         int a=1; func(a);
         则para被推导为int&，最终func的完整形式会是void func(int& && para)，即出现了“引用的引用”，这是非法的，
         但编译器并没有报错，并且程序也正常运行，这是为什么？答案就是引用折叠。经过引用折叠的处理后，实际的func形式为：
         void func(int& para) // 注意引用折叠只应用于编译器解析，我们代码中不能出现形如"int& &&"这样的定义。
         完整的引用折叠规则如下：
         T& &, T& &&, T&& &, 都折叠为T&；
         T&& && 折叠为T&&
         即：如果任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用。

完美转发：完美转发使用了引用折叠，用于参数在多级传递过程中保持原有的引用属性不变（左值引用仍为左值引用，右值引用仍为右值引用）。
        假设有如下函数定义：
        template<typename T> void f(T&& fParam){
            /*注意，不论fParam最终被推导为左值引用还是右值引用，fParam本身都是左值，所以someFunc接收到的形参始终会是左值引用。*/
            someFunc(fParam);
        }
        上例中由于传递给someFunc的实参是左值，所以其形参是左值引用，但如果我们想要someFunc的形参和fParam的引用类型保持一致，怎么办呢？
        这个时候就可以使用完美转发forward，可能的实现：
        template<typename T> T&& forward(typename remove_reference<T>::type& param){
            return static_cast<T&&>(param); // 根据引用折叠规则可知，当param为左值引用类型时返回左值引用，右值引用类型时返回右值引用。
        }
        template<typename T> void f(T&& fParam){
            /*forward接收模板参数并且有通用引用，结合引用折叠规则可知，它会返回跟fparam一样的引用类型，从而做到“完美转发”*/
            someFunc(std::forward<T>(fParam));
        }

## 为什么需要右值及右值引用？

左值及（左值）引用是原本就存在的概念，很好理解，那为什么需要创造出一个“右值”及“右值引用”的概念呢？
答案是为了效率。
首先我们要明确一点：左值引用无法绑定右值，这个是既定的事实，无法改变，企图只使用一种引用让编译器替我们去“智能化”处理各种场景是不切实际的。
然后我们来看看右值及右值引用解决了什么问题：

1、假设我们有个函数定义void foo(Test &t){...}，注意，为了效率（避免拷贝）我们将形参定义为了引用类型。
现在我们想这样调用该函数：foo(Test())。what？编译不过！原因是Test()“实参”是临时的是“將亡值”（右值的一种，另一种是“纯右值”即字面值），
在foo内部时该將亡值已不存在，而形参t是一个引用，引用绑定到一个將亡值，显然是不被允许的。
那怎么办？我们想到了const的引用可以绑定右值，于是我们更改函数定义如下：void foo(const Test &t)。
现在foo(Test())可以通过编译了，但是假定我们foo的原意是需要更改t的内容的，而函数声明又是const，怎么办？
不慌，我们还可以在foo内部使用const_cast<Test&>(t)，将t的const属性去掉。

兜兜转转这么一大圈，我们总算是达成了我们的目的。然而这个过程太繁琐了，并且，const_cast本身是不安全的，
它的建议的用法是“仅在确定目标对象确实是非const时才去使用该操作符去掉其const属性”，意思t原本是一个非const变量，
因故传到此处时变成了const的，这个时候我们去掉const属性才是安全的，因为它原本就没要求const。
总之这种方法并不可取。

所以，对于函数void foo(Test &t)来说，foo(Test())这样的使用方式在之前是难以实现的。
现在我们只需要将函数声明为void foo(Test&& t)，便可以直接使用foo(Test())调用该函数了。其中Test()是一个“右值”，"Test&&"被称为“右值引用”。
原理是，Test&& t一方面它仍然是一个引用，避免了无谓的拷贝，另一方面它是“右值”引用，不同于普通引用必须绑定一个左值，
右值引用可以用来绑定右值（字面值或將亡值），延长它们的生命周期到跟自己一致。

2、无谓的拷贝，降低效率
Test a = Test();
...
Test b(a);
上面代码中，创建b时会执行Test的拷贝构造函数将a的内容拷贝一份给b。
假设现在a已经无用了，我们可否把a的内容直接“转交”给b，而避免再拷贝一份呢？
达成这个目的首先需要让编译器知道“a已无用”这个信息，怎么告知编译器呢？这时就可以传递一个右值引用，
随后编译器会调用一个特殊的构造函数——移动构造函数，它的定义是Test(Test&& t)，来实现移动而非拷贝的目的。
具体操作方式之一：Test b(std::move(a));
PS:语法上，如下代码也应该会通过拷贝构造创建b：
Test createTest(){
    return Test();
}
Test b(createTest());
但由于编译器一般都会针对这种情况做优化，所以实际只发生了一次默认构造。

## 左值引用绑定到左值，右值引用绑定到右值，为何要允许const左值引用绑定到右值？

答案是为了使用上的便利。
我们有将引用绑定到右值上的需求，但是又不能使用常规的引用绑定，否则语义上会违反直觉——当我们针对该引用修改时，
我们期望绑定的对象的内容相应发生了变更，然而我们却找不到该对象。如果不允许修改则没有这个问题。
当然也可以直接使用右值绑定，但右值绑定是允许修改的，有时候我们要求“不可变性”，这是const描述符是必须的。 考虑如下代码片段：

````c++

void test(const int& i){
    ...
}

void main(){
    /** 这里我们传入了一个整型字面值也就是右值实参，由于test只是使用i的值，并不会修改它(const声明)，所以如果直接传字面值逻辑上是没问题的，而且使用上还很便利。
     * 然而，这种使用方式就要求"const int &"能接受右值。既然能带来使用上的便利，又不会造成问题，何乐而不为呢？所以语法上就规定“允许const的左值引用绑定到右值”。否则我们要达成同样的目的需要写如下代码：int tmp=1;test(tmp);太麻烦。
     * 实际上左值引用始终只能绑定左值，本例中编译器会将字面值赋值给一个临时变量，然后再讲临时变量绑定给左值引用，类似如下：
     * int tmp=1;
     * const int& = tmp;
     * */
    test(1); 
    /**
     * 这里我们传入的是一个浮点型字面值，除了会有上面的问题外，还有一个隐藏的问题。
     * test的形参是int，而我们传递的实参是double，这就会导致隐性的类型转换，从而生成一个临时变量，如果是"void test(int& i)"会导致i绑定到一个临时的中间变量，而左值引用是不能绑定到临时变量（將亡值）的。
    */
    test(1.1);
}

````

## 函数参数传递方式如何选用

- 值传递（func(T)）：
    - 参数为基本类型（也称内置类型，由C++语言标准指定，内置于编译器中，不需要引入任何头文件）时，包括void类型、bool、nullptr_t、字符、整型、浮点型。
    - 当函数需要存储参数，且实参的生命周期小于存储的变量时，可使用func(T para)，并在内部使用“T saved = std::move(para)”以避免冗余拷贝。此时需要承担一次拷贝的代价（因为“拷贝消除机制的存在”，很多情况下这次拷贝亦可消除）。 
      简单说函数需要存储实参的副本而非实参本身。
      此种场景下亦可使用func(T& para)，并在内部执行拷贝操作“T saved=para”，但这有两个弊端：
      1、语义反直觉，一般传递引用仅限“使用”的语义，而函数实际执行了“保存”的操作；
      2、效率小于最多等于func(T)，因为func(T)由于拷贝消除机制的存在，理想情况下只需要一次移动操作。而func(T&)函数始终需要进行一次拷贝操作，因为函数内部是无法安全的移动T的。
      此种场景下，亦可使用右值引用func(T&&)，会用移动替代拷贝开销较少，但实参在传递给形参后即被废弃不可用，需保证这点不会造成问题。慎用右值引用作为参数。
    - 当不清楚应该怎样传递时，使用值传递。值传递是最保险的传递方式，而且由于拷贝消除机制的存在很多场景下开销并不大。
- 裸指针（func(T*)）（现代C++绝大多数情形下可以避免使用裸指针）：
    - ~~参数允许null值；~~（可以用std::optional替代，主要还是要从语义上考察）
    - ~~实参为数组类型；（C/C++的数组类型会被转换为指针）~~（可以将实参封装为vector或array）
    - ~~如果函数想要修改参数的指向（重新绑定）则只能使用指针；~~（可以使用reference_wrappers）
- 智能指针(func(shared_ptr<T>)/func(unique_ptr<T>))：
    - 当函数的语义涉及到对象的所有权的转移或者共享时，使用智能指针。独占使用unique_ptr，共享使用shared_ptr。
      “所有权”的含义：对于unique_ptr<T> up来说T对象只能通过up来访问，且其生命周期跟随up的生命周期，若要通过up2来访问则
      需要将up的所有权move到up2。对于shared_ptr<T> sp来说，T对象可以通过sp来访问，若sp2=sp，则亦可通过sp2访问，它们“共享”访问权限
      并且T的生命周期跟随所有sp的集合，只有当没有任意sp在使用T时，T才销毁，换句话说所有的sp共同管理T的生命周期。
    - 不涉及所有权的语义不要使用智能指针作为参数。
- 引用（func(T&)）：
    - 如果函数仅使用参数，不参与其生命周期管理，则应使用引用。若要修改参数使用T&，否则使用const T&。
    - 如果函数不参与实参的生命周期管理，但需要存储参数，且实参的生命周期不小于存储的参数，则可以使用引用。func(T& para){ T& saved=para}，简单说需长时间持有实参的引用。
      但是为了保持语义上的准确性，即“func(T& para)仅使用参数”，这种场景我们用func(std::reference_wrappers<T>)代替，以向使用者明示我们会内部保存该引用。
    - 如果函数需要存储引用到集合，语法上这是不允许的，但语义上又有这个需求，则可以使用引用包装器func(std::reference_wrappers<T> para){ list.push_back(para)}。
- std::function
当函数的形参也是一个函数时，该形参可以有两种形式：函数指针以及std::function，但是函数指针有一定的局限性，它无法统一表示“一个函数对象”的语义。
比如实参可能来自一个普通函数取地址、一个成员函数取地址、一个lambda表达式以及一个std::function对象，所以当我们需要“一个函数”作为参数时，一般选用std::function，它能接受所有上述类型的实参。
一般std::function作为参数传递时使用值传递，尤其是异步回调的场景。

- 拷贝消除机制
现代c++编译器在参数传递以及返回值传递过程中已经具备“拷贝消除”功能，使用值传递的方式既安全且方便。考虑如下代码：

```c++

class Foo {
    bar(Object o) { // 形参为值传递对象
        o_ = std::move(o); // 将形参移动赋值给成员变量。
    }

    Object o_;
};

// 用户调用
foo.bar(Object()); //"Object()"为纯右值。 c++17开始由于编译器“拷贝消除”功能，"Object()"不会在调用方生成临时对象，
                   //而是在bar的函数调用栈内直接构造为形参，既没有copy也没有move。 调用的整个过程总共就发生了一次构造和一次move。
foo.bar(existed_object); // 实参非右值，发生一次从实参到形参的拷贝。总共一次copy和一次move。
foo.bar(std::move(existed_object))； // 总共两次move（实参->形参，形参->成员变量）

```
ref:
https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f-functions
https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-summary-smartptrs
https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-smart
https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-const
https://blog.csdn.net/qq_21438461/article/details/131297103

## 函数返回值，值、引用、指针如何选用？

当期望返回左值时使用引用（如vector下标操作符v[i]，方便用于左值的场景v[i]=a）；
当期望返回值能在正常时表示要获取的对象，在异常时反馈调用者发生了异常时（返回null），使用指针；
其它情况返回“值”；

对于非基本类型，返回值可能有拷贝开销的担忧，但现在的编译器都会开启RVO(Return Value Optimization)和NRVO(Named Return Value Optimization)优化。
不会经历从临时对象到目标对象的拷贝，而是直接在调用者的栈空间生成目标对象。例如：

````c++
class RVOTest{
    RVOTest(){
        cout << "RVOTest constructor"<<endl;
    }
};

RVOTest testRVO(){
    return RVOTest(); 
}

RVOTest testNRVO(){
    RVOTest r = RVOTest(); 
    return r; 
}

void main(){
    RVOTest r = testRVO();  // 整个过程只创建了一个RVOTest，只会打印一次“RVOTest constructor”
    RVOTest r2 = testNRVO();  // 整个过程只创建了一个RVOTest，只会打印一次“RVOTest constructor”
}

````

## 类成员变量值对象、指针、引用如何选用？

首先，现代C++我们不建议再使用裸指针作为类成员。因为成为类成员即意味着需要管理其生命周期，现代C++管理对象生命周期运用RAII思想，这样的场景下应摒弃裸指针。
假设类定义为 class A{ T t;}; 下面分情况讨论：
- t被A独占
- t被多个类或外部代码共享
- t是来自某个唯一的所有者X，且X生命周期长于A
- //NEXT
成员为基本类型使用值对象；
成员和类是组合关系使用值对象，成员和类是聚合关系使用指针；
类成员尽量避免使用引用；

````c++

class A{
};

class B{
    class B(const A& a): a_(a){}
    
    A& a_; // 不良设计
};

void main(){
    B b(A()); //错误！ A()是一个將亡值，尽管B的构造函数接受一个A的const引用可以延长该將亡值的生命周期，
              //但生命周期只是延长至和形参a一致，并非和成员变量a_一致，当构造函数返回a和將亡值均销毁，a_也变成了悬空引用。
}

// 改进

使用智能指针替代引用。

````


## 智能指针shared_ptr和unique_ptr如何选用？

unique_ptr独占指向的对象，即对象只允许一个指针指向它，这样更安全。unique_ptr较shared_ptr也更高效，因为它没有引用计数。
不知道如何选用时，默认选用unique_ptr，等出现需要多个指针指向同一个对象的场景时再使用shared_ptr。

## Java为什么没有左右值、左右引用、特殊构造函数这些概念？

这些概念本质上都是为了更高效的使用内存。
C++是相对底层的语言，它提供了操控内存的能力，更高效的同时也带来了相应的复杂性，再加上有C的包袱。
而Java有内存回收机制，程序员不需要手动管理内存，所以不需要这些概念。Java参数就是值传递，不过非基本类型传递的是对象地址，所以不必拷贝对象本身，类似指针传递的效果。

## 特殊成员函数有哪几种？编译器何时会生成它们的默认版本？何时会触发调用？定义示例？

特殊成员函数是指C++中专门用于控制对象的生命周期的一组函数，并且如果用户自己未定义编译器“可能”自动为其生成，我们称之为该函数的“默认”版本，目前有6个：
构造函数、析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数(C++11引入)、移动赋值运算符(C++11引入)。
**按用途又可分3类：构造（构造函数、拷贝构造函数、移动构造函数）、析构（析构函数）、赋值（拷贝赋值运算符、移动赋值运算符）。**


````c++
class C{
    C();  // 构造函数
    ~C();  // 析构函数
    C(const C& c); // 拷贝构造函数
    C& operator=(const Widget&); // 拷贝赋值运算符
    C(C&& c); // 移动构造函数
    C& operator=(Widget&&); // 移动赋值运算符
}
````

- 编译器自动生成默认版本的规则（std>=C++11）：

默认生成的特殊成员函数都具有public访问权限且是inline的非虚函数（**析构例外**）。通常，**如果这些函数不被相关代码使用，编译器不会为其产生真正的函数代码。**
如果基类析构函数是虚函数，则编译器为派生类生成的析构函数也是个虚函数。
默认的复制或移动都是指对非静态成员的操作，它们都是“按成员复制”或“按成员移动”的。而“按成员移动”实际上更像是按成员移动的请求，
因为**有些类型不具备移动操作，对于这些对象会通过其复制操作来实现“移动”。**

默认构造函数：仅当类不存在用户定义的构造函数（**任意构造函数，包括普通构造、拷贝构造、移动构造**）时才自动生成。
             若类中有成员为其它类实例：M m，则调用M的默认构造函数初始化m。
             注意，我们提到“默认”xxx函数时，均指编译器为我们自动合成的版本，并非指我们不传入任何参数时调用的版本，像“A(val=1)”这种，
            虽然会被“A a;”这样的代码触发调用，但它是用户自定义的，不是编译器自动生成的构造函数，不是我们所指的“默认构造函数”。 
            所以从调用形式上我们不能确定用户是否使用了默认版本的构造函数。
默认析构函数：仅当类不存在用户定义的析构函数时才自动生成。
             不做任何事（也称平凡析构），比如该对象还有指针需要释放。
             仅当基类析构为虚函数时该类析构才为虚函数。析构默认noexcept。
             析构不能是私有的或delete的，否则对象无法销毁。
默认拷贝构造函数：当类不存在用户定义的拷贝构造以及移动操作（**包括移动构造和移动赋值操作符**）时才自动生成。
                注意，在当前自定义拷贝赋值或析构函数时，仍会生成默认的拷贝构造函数，但该行为会被逐渐废弃。
默认拷贝赋值运算符：当类不存在用户定义的赋值操作符以及移动操作（包括移动构造和移动赋值操作符）时才自动生成。
                注意，在当前自定义拷贝构造或析构函数时，仍会生成默认的拷贝赋值操作符，但该行为会被逐渐废弃。
默认移动构造函数和移动赋值运算符：当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。
两个拷贝操作是独立的，声明一个不会限制编译器生成另一个。两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个。移动操作的合成条件最苛刻。

总结：如果自定义了其中一个尽量也自定义其余的。

同样是从一个对象构建另一个对象，拷贝构造函数和拷贝赋值运算符的区别在于：
拷贝“构造”函数用于将一个对象复制到“新创建的”对象中。也就是说，它用于初始化过程中。而赋值“运算符”用于将一个对象的内容赋值给另一个“已存在的”对象。从他们的名字也可以窥见区别“构造”和“运算符”，一个是用于创建新对象，一个是在对象已存在的情况下的操作。

- 针对拷贝及移动函数的经验法则（三五法则，三指c++98中的析构、拷贝构造、拷贝赋值，五再加上c++11中的移动构造、移动赋值）

法则一：如果你自定义了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你也应该定义其余两个（注意是应该定义不是说不定义就会没有，编译器会自动合成默认的版本。但有些行为会阻止编译器自动合成）。
通常，若一个类需要析构函数，则代表其默认的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员（析构时需要手动去释放指针指向的内存）。若存在自定义（且正确）的析构函数，但使用默认的拷贝构造函数，那么拷贝过去的也只是指针，此时两个对象的指针变量同时指向同一块内存，指向同一块内存的后果很有可能是在两个对象中的析构函数中先后被释放两次。所以需要额外的拷贝控制函数去控制相应资源的拷贝。

法则二：若自定义拷贝构造则也需要自定义赋值操作符，反之亦然
拷贝和赋值的区别仅在于是针对初始化对象还是已有对象，他们对拷贝的需求是一样的。

法则三：析构函数不能是私有的或delete的
如果类的析构函数是私有的，那么成员便无法销毁。

法则四：如果一个类有私有的或不可访问的析构函数，那么其默认的拷贝构造函数会被定义为私有的

法则五：如果一个类有const或引用成员，则不能使用默认的拷贝赋值操作
原因很简单，const或引用成员只能在初始化时被赋值一次，而默认的拷贝赋值操作会对所有成员都进行赋值。显然，它不能赋值 const 和引用成员，所以默认的拷贝构造函数不能被使用。

法则六：若自定义拷贝函数则考虑自定义移动函数，反之亦然。（移动构造应声明为noexcept）

如果用户自定义了其中一个，导致抑制了编译器自动生成其它几个，但仍想使用编译器自动生成的另外几个，则可以使用"default"指定：

````c++
class Widget {
    public:
    ~Widget(){...}                           //用户定义的析构函数。它会阻止编译器自动生成其它特殊函数。（多态基类通常有一个虚析构函数，因为如果它们非虚，一些操作（比如通过一个基类指针或者引用对派生类对象使用delete或者typeid）会产生未定义或错误结果。）
    Widget(const Widget&) = default;        //显式声明使用编译器生成的默认拷贝构造函数
    Widget& operator=(const Widget&) = default; //显式声明使用编译器生成的默认拷贝赋值运算符
};
````

- 触发时机

````c++
// 默认构造函数触发
// 当用户构造对象未提供任何参数时，如果用户没有自定义“不需要提供参数”（不一定是无参，因为带默认值的参数使用上跟无参一样）的构造函数版本，则会触发默认构造函数。
// A a0(); // 特别注意，这是声明函数，而非调用默认构造！
A a1； // 最常见的使用默认构造的情形；
A a2{}; // 这里不会触发形参为初始化列表的构造函数版本。

// 拷贝构造函数
// 总体来说，在用一个对象“创建”另一个对象时会发生拷贝构造。具体有如下场景：
A a3(a2); // 直接调用拷贝构造函数
A a4=a3; // 注意这里并不是赋值，因为a4是新创建，并不是已存在。
//void testCopy(A a);
testCopy(a4); // 实参拷贝到形参。所以可以考虑形参为引用类型A&，避免拷贝。注意，现代编译器大多开启了“Copy elision”功能，
              //会针对参数及返回值拷贝行为做优化，尽力剔除无意义的拷贝。如testCopy(A());这样的调用就不会触发拷贝，而是直接为形参创建对象。
//A createA();
A a5=createA(); // 返回值拷贝给a5。注意开启RVO的情况下编译器会优化去掉这次冗余的拷贝，直接针对a5创建对象。c++17开始这是编译器的强制行为。
A arr[] = {a1, a2, a3}; // 数组初始化。三次拷贝
vector<A> v;
v.push(A()); // 容器添加元素，先创建一个临时对象，然后拷贝给形参
// v.emplace(A()) // emplace版本不会发生拷贝，而是直接为形参创建对象。优先使用emplace版本

// 拷贝赋值操作符
// 拷贝赋值操作符仅发生在如下情形：
A a6;
a6=a5; // 一定要存在赋值操作符"="才可能触发，然后左侧一定要是已经存在的对象，如果是“A a6=a5;”这样就是拷贝了，最后右侧的对象要是个左值，若是右值则会触发移动赋值操作符。

// 移动构造函数
// 移动脱胎于拷贝，是为了解决一些场景下冗余拷贝而生的。所以移动构造触发的场景同拷贝构造，除了一点区别：当源对象（拷贝的来源）是左值时发生拷贝，是右值时则发生移动。
A a7=std::move(a6); // move将左值a6变为了右值，所以不再触发拷贝，而是触发移动构造。
testCopy(move(a7));

// 移动赋值操作符
// 移动赋值操作符和拷贝赋值操作符的关系同移动构造和拷贝构造，所以：当赋值的源对象是左值时发生拷贝，是右值时则发生移动。
A a8;
a8=std::move(7);

````

## 为什么构造函数不能是虚函数，析构函数一般是虚函数

1、构造函数不能声明为虚函数
1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等
2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了
2、析构函数最好声明为虚函数
首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。
如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

## 类型推导

### 模板类型推导

分成三种情况来讨论，基于如下的伪代码模板：

````c++
template<typename T>
void f(ParamType param);

f(expr);                        //从expr中推导T和ParamType
````

- ParamType是一个指针或引用，但不是通用引用

````c++

template<typename T>
void f(T& param);   

int x = 27;                    
const int cx = x;              
const int& rx = x;             

f(x);                           //T是int，param的类型是int&
f(cx);                          //T是const int，param的类型是const int&
f(rx);                          //T是const int，param的类型是const int&。注意T保留了const，但丢弃了引用属性！

// 数组的情形比较特殊！
const char name[] = "J. P. Briggs";     //name的类型是const char[13]
// const char * ptrToName = name;          //数组退化为指针
f(name);         //name是一个数组，不同于普通的形参数组退化为指针，引用形参情况下，T被推导为真正的数组const char[13]，param被推导为const char (&)[13]。
/*这种又臭又长的推导会带来一个有趣用法：我们可以创建一个模板函数来推导出数组的大小。
//在编译期间返回一个数组大小的常量值（//数组形参没有名字，
//因为我们只关心数组的大小）
template<typename T, std::size_t N>                    
constexpr std::size_t arraySize(T (&)[N]) noexcept   // 省略了形参名字   
{                                                      
    return N;                                          
}                                                      
*/

// 函数类型的情况和数组类似！
void someFunc(int, double);         //someFunc是一个函数，类型是void(int, double)
f2(someFunc);                       //param被推导为指向函数的引用，类型是void(&)(int, double)

````

````c++
template<typename T>
void f(const T& param);         //param现在是reference-to-const

int x = 27;                     
const int cx = x;               
const int& rx = x;              

f(x);                           //T是int，param的类型是const int&。注意T的推导受到了ParamType的影响。由于ParamType中有了const，T推导时不再带上const！
f(cx);                          //T是int，param的类型是const int&
f(rx);                          //T是int，param的类型是const int&

````

对于指针的情形和引用类似。

- ParamType是一个通用引用

通用引用的类型推导会应用“引用折叠”规则。

````c++
template<typename T>
void f(T&& param);              //param现在是一个通用引用类型！
        
int x=27;                      
const int cx=x;                
const int & rx=cx;             

f(x);                           //x是左值，所以T是int&。只有在通用引用的情形下，且实参为左值时，T才会被推导为引用！
                                //param类型也是int&

f(cx);                          //cx是左值，所以T是const int&，
                                //param类型也是const int&

f(rx);                          //rx是左值，所以T是const int&，
                                //param类型也是const int&

f(27);                          //27是右值，所以T是int，
                                //param类型就是int&&

````

- ParamType既不是指针也不是引用

````c++
template<typename T>
void f(T param);                //以传值的方式处理param。这意味着无论实参传递什么param形参都会成为它的一份拷贝

int x=27;                      
const int cx=x;                
const int & rx=cx;             

f(x);                           //T和param的类型都是int
f(cx);                          //T和param的类型都是int。忽略const属性！因为param是cx的拷贝，cx的const属性与他无关。
f(rx);                          //T和param的类型都是int。忽略const和引用属性！因为param是cx的拷贝，rx的const和引用属性与他无关。

const char* const ptr ="Fun with pointers";  //ptr是一个常量指针，指向常量对象const char*
f(ptr);                         //T和param的类型都是const char*。注意ptr自身的const属性被忽略了，因为param是ptr的拷贝。

// 数组比较特殊！
const char name[] = "J. P. Briggs";     //name的类型是const char[13]
// const char * ptrToName = name;          //数组退化为指针
f(name);         //name是一个数组，但是T被推导为const char*

// 函数类型的情况和数组类似！
void someFunc(int, double);         //someFunc是一个函数，类型是void(int, double)
f2(someFunc);                       //param被推导为指向函数的引用，类型是void(*)(int, double)

````

### auto类型推导

编译器会将auto转为模板推导。
当一个变量使用auto进行声明时，auto扮演了模板中T的角色，变量的类型说明符扮演了ParamType的角色。
废话少说，这里便是更直观的代码描述，考虑这个例子：
auto x = 27;
这里x的类型说明符是auto自己，另一方面，在这个声明中：
const auto cx = x;
类型说明符是const auto。另一个：
const auto& rx = x;
类型说明符是const auto&。在这里例子中要推导x，cx和rx的类型，编译器的行为看起来就像是认为这里每个声明都有一个模板，然后推导过程就跟上面提到的模板推导一样了：

````c++
template<typename T>            //概念化的模板用来推导x的类型
void func_for_x(T param);

func_for_x(27);                 //概念化调用：
                                //param的推导类型是x的类型

template<typename T>            //概念化的模板用来推导cx的类型
void func_for_cx(const T param);

func_for_cx(x);                 //概念化调用：
                                //param的推导类型是cx的类型

template<typename T>            //概念化的模板用来推导rx的类型
void func_for_rx(const T & param);

func_for_rx(x);                 //概念化调用：
                                //param的推导类型是rx的类型

````

### decltype

绝大多数情形下decltype返回的类型非常直观符合预期。但存在两种特殊情形：
对于T类型的不是单纯的变量名的左值表达式，decltype总是产出T的引用即T&；
C++14支持decltype(auto)，就像auto一样，推导出类型，但是它使用decltype的规则进行推导；

````c++
decltype(auto) f1()
{
    int x = 0;
    return x;                            //x是一个变量的名字，所以decltype(x)是int，所以f1返回int
}

decltype(auto) f2()
{
    int x = 0;
    return (x);                          //(x)是一个表达式，且是个左值，所以decltype((x))是int&，所以f2返回int&
}

...

Widget w;

const Widget& cw = w;
auto myWidget1 = cw;                    //auto类型推导，myWidget1的类型为Widget。会忽略const属性，详见上面对auto推导的说明。
decltype(auto) myWidget2 = cw;          //如果想要推导结果跟w类型一致，可以使用decltype(auto)，myWidget2的类型是const Widget&


````

## 初始化

````c++
int x(0);               //使用圆括号初始化
int y = 0;              //使用"="初始化
int z{ 0 };             //使用花括号初始化。统一初始化语法
int z = { 0 };          //使用"="和花括号（C++通常把它视作和只有花括号一样）
````

“乱的一塌糊涂”是指在初始化中使用"="可能会误导C++新手，使他们以为这里发生了赋值运算，然而实际并没有。对于像int这样的内置类型，
研究两者区别就像在做学术，但是对于用户定义的类型而言，区别赋值运算符和初始化就非常重要了，因为它们涉及不同的函数调用。

````c++
Widget w1;              //调用默认构造函数
Widget w2 = w1;         //不是赋值运算，调用拷贝构造函数
w1 = w2;                //是赋值运算，调用拷贝赋值运算符（copy operator=）
````

C++11使用统一初始化（花括号初始化）来整合这些混乱且不适于所有情景的初始化语法，所谓统一初始化是指在任何涉及初始化的地方都使用单一的初始化语法。 
它基于花括号{}。花括号表达式还有一个好处，它对于C++最令人头疼的解析问题有天生的免疫性。
我们可以显式调用构造函数创建对象：Widget w1(10);  //使用实参10调用Widget的一个构造函数
但是如果你尝试使用相似的语法调用Widget无参构造函数，它就会变成函数声明：Widget w2(); //最令人头疼的解析！声明一个函数w2，返回Widget
由于函数声明中形参列表不能带花括号，所以使用花括号初始化表明你想调用默认构造函数构造对象就没有问题：Widget w3{}; //调用没有参数的构造函数构造对象。

花括号初始化有诸多好处，但是缺点是有时它有一些令人惊讶的行为。这些行为使得花括号初始化、std::initializer_list和构造函数参与重载决议时本来就不清不楚的暧昧关系进一步混乱。

````c++
class Widget { 
public:  
    Widget(int i, bool b);     
    Widget(int i, double d);   
    Widget(std::initializer_list<long double> il);      //接受初始化列表的构造函数。initializer_list只能接受同一种类型的
    operator float() const;                             //转换为float
}; 

Widget w2{10, true};    //原意是使用第一个构造，但是现在调用带std::initializer_list的构造函数(10 和 true 转化为long double)
Widget w4{10, 5.0};     //原意是使用第二个构造，但是现在调用带std::initializer_list的构造函数(10 和 5.0 转化为long double)
Widget w6{w4};          //期望使用拷贝构造，但是实际调用std::initializer_list构造函数（w4转换为float，float转换为double）
Widget w8{std::move(w4)}; //期望使用移动构造，但是实际调用std::initializer_list构造函数（与w6相同原因）
Widget w9{};             //特例，调用默认构造函数，没有调用initializer_list的版本
````

所以如果你的类决定支持initializer_list版本的构造函数，请小心设计，避免使用上出现意外。

## noexcept

noexcept是函数接口的一部分，这意味着调用者可能会依赖它
noexcept函数较之于non-noexcept函数更容易优化
noexcept对于移动语义，swap，内存释放函数和析构函数非常有用
大多数函数是异常中立的（可能抛也可能不抛异常）而不是noexcept

一般我们只针对较简单的函数声明noexcept，因为noexcept对调用者是一种承诺，承诺失效是对调用者的破坏，
而复杂函数的函数内部还有更深层的调用，我们很难保证，而且复杂函数往往有更大的变动可能，总之很难保证noexcept。
几种特殊的函数常常声明为noexcept：移动语义，swap，内存释放函数和析构函数（默认就是）。

## constexpr

constexpr对象的值编译期可知。
编译期可知的值“享有特权”，它们可能被存放到只读存储空间中。对于那些嵌入式系统的开发者，这个特性是相当重要的。
更广泛的应用是“其值编译期可知”的常量整数会出现在需要“整型常量表达式（integral constant expression）的上下文中，这类上下文包括数组大小，
整数模板参数（包括std::array对象的长度），枚举名的值，对齐修饰符（译注：alignas(val)），等等。

````c++
int sz;                             //non-constexpr变量
…
constexpr auto arraySize1 = sz;     //错误！sz的值在
                                    //编译期不可知
std::array<int, sz> data1;          //错误！一样的问题
constexpr auto arraySize2 = 10;     //没问题，10是
                                    //编译期可知常量
std::array<int, arraySize2> data2;  //没问题, arraySize2是constexpr

const auto arraySize = sz;         //没问题，arraySize是sz的const复制
std::array<int, arraySize> data;   //错误，arraySize值在编译期不可知。const不提供constexpr所能保证之事，因为const对象不需要在编译期初始化它的值。

````

简而言之，所有constexpr对象都是const，但不是所有const对象都是constexpr。如果你想编译器保证一个变量有一个值，
这个值可以放到那些需要编译期常量（compile-time constants）的上下文的地方，你需要的工具是constexpr而不是const。
涉及到constexpr函数时，constexpr对象的使用情况就更有趣了。如果实参是编译期常量，这些函数将产出编译期常量；
如果实参是运行时才能知道的值，它们就将产出运行时值。这听起来就像你不知道它们要做什么一样，那么想是错误的，请这么看：
constexpr函数可以用于需求编译期常量的上下文。如果你传给constexpr函数的实参在编译期可知，那么结果将在编译期计算。
如果实参的值在编译期不知道，你的代码就会被拒绝。 当一个constexpr函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，
运行时计算它的结果。这意味着你不需要两个函数，一个用于编译期计算，一个用于运行时计算。constexpr全做了。

## 为什么C/C++需要头文件，而其它语言如Java不需要？

首先一个项目由很多源文件组成，假设有A,B源文件，他们之间是需要共同协作以完成某个功能的。这点对各种语言都一样。
假设B需要使用A的功能，C++是通过在B中include A的头文件A.h来实现的，而Java则是直接import A来实现的。
Java不需要头文件，因为Java编译后的目标产物class文件包含了自我描述的符号信息，相当于包含了A.h的内容。所以它直接import A(这里的A实际是A.class，也就是编译目标产物)就行了。但是相应的，这部分信息也会增大目标产物的体积以及增大运行时内存消耗。
C++的目标产物没有包含自我描述的符号信息，因为这部分对于运行来说不是必须的，或者说如果事先引入了A.h，这部分内容就可以从目标产物中剔除，这样可以减少目标产物体积以及运行时内存消耗。而C/C++设计目标之一就是注重效率，自然是不会把这种可以被视为“冗余”的信息带到目标产物的。所以C++不能像Java那样通过在B中直接include A（的目标产物）达到AB协作的目的，而是留给了开发者一项额外任务——编写A的头文件A.h，然后在B中include A.h。

## c++ 头文件应该包含哪些内容？

在**预处理阶段**，编译器将头文件内容**原封不动地复制**到包含语句(#include)处。在源文件编译时，连同被包含进来的头文件内容一起编译，生成目标文件(.obj)。

编译的过程是**先以单个源文件为单位独立编译为.o文件**，然后再把各个.o文件链接在一起生产最终的可执行文件。
这就要求经过预处理后（include展开后）编译器要能**在当前文件**看到所有用到的类、函数、变量等的**声明**。

头文件规范：

- 尽量精简
  具体来说，只声明必要的内容，只依赖必要的其它头文件。比如A.cpp的头文件A.h，它的作用是**为A对外提供的功能做声明**，从而使得需要使用A功能的人通过include A.h即可，所以它不应包含A本身依赖的其它模块内容，比如A为了完成某项功能需要引入C.h，这个就不应该在A.h中include，而应该在A.cpp中include。

- 只声明，不定义
  头文件被多处使用意味着在多处有它的副本，如果包含定义，则会导致重复定义，编译失败。
  例外：
  全局的const对象的定义，全局的static对象定义。因为它们的作用域是本文件内。
  inline函数定义。因为inline是是直接展开到调用点，所以编译器需要知道它的完整定义。如果函数成员在类的定义体中被定义，那么编译器会视这个函数为inline的。
  class定义。编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象内存应该如何布局。

- 头文件要在其源文件中被引入
  编译器会检查两个文件之间的差异，并确保两个之间的一致性。

- 如果B的“未完整声明”可以满足需求，就不需要在A.h中include B.h了

- 不要依赖间接导入，直接导入你需要的依赖
  若 foo.cc 使用了 bar.h 的符号, 就在foo.cc中导入 bar.h, 不要依赖foo.h已经导入的bar.h（有重入保护，不用担心重复include）。
  这样当foo.h将来因某种原因删除无用的bar.h时不会影响到foo.cc。
  
  ````c++

  //file A.h
  // include "B.h" 这个就不需要了
  class B; // 前向声明（未完整声明）
  class A{
    B* b; // 指针使用未完整声明即可。对于编译器来说所有指针大小都一样，能确认b大小就能确认class A的内存布局。
  }
  ````

- 头文件中不使用using namespace
  头文件使用 using namespace XXX 会破坏 namespace 的封装性。强制头文件的使用者也使用 using namespace XXX,从而引起混乱。

- 自己的头文件应该第一个被包含
  // file A.cpp
  include "A.h"  // A自身的头文件首先包含
  include "B.h"  // 其次是其它模块的
  include <string.h> // 最后是系统提供的

## 匿名命名空间和static

匿名命名空间和static都限定了符号仅当前文件可见，前者是c++提倡的方式。
头文件中不要使用匿名命名空间。

## 内联(inline)命名空间有什么作用

内联命名空间对于用户来说，使用起来就像不存在一样。
它主要用于库开发，方便在用户无感的情况下升级库API且保留用户使用老版本API的权利。

````c++
// 库代码
#include <iostream>

namespace Parent {
    
    // 不需要将整套API全部塞到嵌套命名空间（V1,V2,V3），
    // 没有多重版本的接口仍然放在最外层命名空间，只把需要升级的接口挪到嵌套命名空间。
    void bar() {
        std::cout << "bar() v1.0" << std::endl;
    }

    namespace V1 {
        // 只把需要升级的接口挪到嵌套命名空间。
        void foo() {
            std::cout << "foo() v1.0" << std::endl;
        }
    }

    // use v2 as newest version
    /*inline*/ namespace V2 { // V3出来后，原本最新的V2版本的inline要去掉
        void foo() {
            std::cout << "foo() v2.0" << std::endl;
        }
    }

    // use v3 as newest version
    inline namespace V3 {
        void foo() {
            std::cout << "foo() v3.0" << std::endl;
        }
    }
}

// 用户代码
int main() {
    /* 用户代码不用改就可以自动升级到最新版本的foo函数（V1->V2->V3版本）*/
    Parent::foo(); 
    // 如仍需要旧版本，则需要如下调用（这种情况下对用户来说要修改代码了）
    Parent::V1::foo();
    Parent::V2::foo();
}


````

## 模板元编程


## TODO

阅读开源项目

## 编码规范

- 不应在头文件中使用 using 指令
  在头文件的全局作用域中使用 using 指令极易造成命名冲突，且影响范围难以控制。
- 不应在头文件中使用静态声明
  头文件中由 static 关键字声明的对象、数组或函数，会在每个包含该头文件的翻译单元或模块中生成副本造成数据冗余，如果将静态数据误用作全局数据也会造成逻辑错误。
  类的静态成员不受本规则限制。
  在头文件中实现的内联或模板函数中，也不应使用静态声明，如：
    // In a header file
    inline void bar() {
        static Type obj;   // Non-compliant
        ....
    }
  另外，由 const 或 constexpr 关键字限定的常量也具有静态数据的特性，在头文件中定义常量也面对这种问题，基本类型的常量经过编译优化可以不占用存储空间（有取地址操作的除外），而对于非基本类型的常量对象或数组也不应在头文件中定义。
- 不应在头文件中定义匿名命名空间
  在头文件中定义匿名命名空间相当于在头文件中定义静态数据，头文件被多个源文件包含时会造成数据冗余。
- 不应在头文件中实现函数或定义对象
  在头文件中定义的函数或对象会被引入不同的翻译单元（translate-unit）造成编译冲突。
  定义为常量、内联、模板的函数或对象可不受本规则约束，静态函数或对象也不受本规则约束，但受规则 staticInHeader 限制。
- 不应在匿名命名空间中使用静态声明
  匿名命名空间中的元素已具有内部链接性（internal linkage），不应再用 static 关键字限定。
  namespace {
    static int i = 0;   // Non-compliant。多余的
    static int foo() {  // Non-compliant
        return i++;
    }
  }
- 全局对象的初始化不可依赖未初始化的对象
  extern int i;   // Defined in other translate unit
  int j = i;      // Non-compliant。不能保证外部的i已初始化
- 全局对象不应同时被 static 和 const 等关键字限定
  在 C++ 语言中，由 const 或 constexpr 关键字限定的全局对象已具有内部链接性（internal linkage），不应再被 static 关键字限定。
  示例：
  static const int i = 123;   // Non-compliant, redundant ‘static’
  应改为：
  const int i = 123;   // Compliant
- 全局及命名空间作用域中禁用 using 指令
  通过 using 指令将其他命名空间中的名称一并引入当前命名空间，是对命名空间机制的破坏，会造成难以预料的冲突与混乱。
  简单说仅在函数内部使用using以尽量缩小作用域。

  ````c++
  // In global namespace
  using namespace std;           // Non-compliant
  using namespace myspace;       // Non-compliant
  //using namespace std::string;    // 如果一定要用也要尽量精确范围
  
  namespace myspace {
      using namespace hisspace;  // Non-compliant
  }
  
  //在函数作用域内可适当放宽要求，如：
  
  void foo() {
      using namespace myspace;   // Let it go
  
      type x;                    // Using myspace::type
      some_fun(x);               // Using mysapce::some_fun
  }
  
  //建议用 using 声明 代替 using 指令：
  
  void foo() {
      using myspace::type;       // Compliant, using-declaration
      using myspace::some_fun;   // Compliant, using-declaration
  
      type x;
      some_fun(x);
  }
  ````

- 避免隐式类型转换
  不要定义隐式类型转换. 定义类型转换运算符和单个参数的构造函数时（拷贝和移动构造函数除外, 因为它们不执行类型转换.）, 请使用 explicit 关键字 (keyword).
  隐式转换可能掩盖类型不匹配错误. 有时目标类型与用户预期不符, 甚至用户不知道会出现类型转换.
  隐式转换降低了代码可读性. 尤其是存在函数重载的情况下, 难以判断实际调用的函数.
  单参数构造函数可能被意外当作隐式类型转换, 这可能不是作者的本意.
  如果单参数构造函数没有 explicit 标记, 读者无法判断这是隐式类型转换还是遗漏了 explicit 标记.
  隐式类型转换可能导致调用歧义 (call-site ambiguity), 尤其是存在双向隐式转换的情况下. 这种情况可能是因为两种类型都定义了隐式转换, 或者一种类型  同时定义了隐式构造函数和隐式转换运算符.

  对于某些可互换的类型, 隐式类型转换是必要且恰当的, 例如两种类型的对象只是同一底层值的不同表示形式. 
  接受多个参数的构造函数可以省略 explicit 标记. 接受单个 std::initializer_list 参数的构造函数也应该省略 explicit 标记, 以支持拷贝初始化 (copy-initialization, 例如 MyType m = {1, 2};).

- 类的公有接口必须明确指明该类是可拷贝的、仅可移动的、还是既不可拷贝也不可移动的
  每个类的公有接口都应该明确指明该类是否支持拷贝和移动操作. 通常应在声明的 public 部分显式声明或删除对应的操作.
  具体来说, 可拷贝的类应该显式声明拷贝运算符, 仅能移动的类应该显式声明移动运算符, 既不能拷贝也不能移动的类应该显式删除复制运算符. 可拷贝类也可以  声明移动运算符, 以支持更高效的移动. 您可以显式声明或删除所有四个拷贝和移动运算符, 但这不是必需的. 如果您提供拷贝或移动赋值运符, 则必须提供同  类的构造函数.
- 所有继承都应该使用 public 的访问权限
  如果要实现私有继承, 可以将基类对象作为成员变量保存. 当您不希望您的类被继承时, 可以使用 final 关键字.
- 访问控制
  类的 所有 数据成员应该声明为私有 (private), 除非是常量. 这样做可以简化类的不变式 (invariant) 逻辑, 代价是需要增加一些冗余的访问器 (accessor) 代码 (通常是 const 方法).
- 函数返回值
  倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空（这种情况下也可以考虑用optinal替代）。
- 友元
  谨慎使用友元，它会破坏封装。
  经常用到友元的一个地方是将 FooBuilder 声明为 Foo 的友元, 以便 FooBuilder 正确构造 Foo 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.
- 异常 // TODO
- 宏定义
  C++中尽量避免使用宏定义，可以内联函数和const变量替代。
- sizeof
  尽可能用 sizeof(varname) 代替 sizeof(type).使用 sizeof(varname) 是因为当代码中变量类型改变时会自动更新。
- 命名规范
  

### 全局对象注意事项

- 尽量避免使用全局变量
- 若要使用，尽量只使用能被“平凡析构”的全局变量。更进一步，尽量只使用基本类型的全局变量。
  所谓平凡析构即析构函数不会做任何事情, 包括成员和基类的析构函数。正式地说, 就是这一类型 没有用户定义的析构函数或虚析构函数, 且所有成员和基类也能平凡地析构。
- 初始化顺序
  全局对象的构造函数在程序开始执行之前就会被调用，这意味着它们会在任何函数（包括 main 函数）之前被初始化。因此，必须确保全局对象的构造函数不依赖于任何在构造函数执行时尚未初始化的其他全局对象或静态变量。
- 析构顺序
  与构造函数相反，全局对象的析构函数会在程序结束时被调用，且调用顺序与构造函数的调用顺序相反。这意味着如果一个全局对象的析构依赖于另一个全局对象的状态，那么需要特别注意析构函数的执行顺序，以避免出现依赖的对象已经被析构而导致的问题。
- 静态存储期
  全局对象具有静态存储期，这意味着它们在程序的整个运行过程中都存在，而不是在创建它们的函数返回时就被销毁。因此，需要谨慎管理全局对象的资源，避免资源浪费或内存泄漏。
- 多线程安全
  在多线程环境中使用全局对象时，需要特别注意线程安全问题。如果多个线程可能同时访问和修改全局对象，那么必须采取适当的同步措施来避免数据竞争和不一致的状态。
- 命名冲突
  由于全局对象在整个程序中都是可见的，因此需要特别注意避免命名冲突。最好使用具有描述性的名称，并遵循一定的命名规范，以减少与其他全局变量或函数名称冲突的可能性。
